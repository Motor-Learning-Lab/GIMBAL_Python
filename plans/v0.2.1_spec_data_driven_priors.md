# v0.2.1 Detailed Specification — Final Version

# v0.2.1 Detailed Specification — Data‑Driven Joint Direction Priors & Basic 3D Keypoint Cleaning

*GIMBAL‑HMM — Version 0.2.1*

**Status:** Final specification for Copilot implementation
**Depends on:** v0.2 Overview, v0.2.0 Completion Report
**Reviewed:** Copilot Review Round 1

---

## 1. Goals & Scope

Version 0.2.1 introduces the first data‑dependent components into the GIMBAL‑HMM pipeline. The goal is to stabilize later inference phases by supplying:

1. **Basic 2D keypoint cleaning** (per camera)

   * Detect extreme 2D outliers (per-joint jumps, bone-length violations)
   * Convert 2D outliers → NaN
   * Interpolate short 2D gaps

2. **Basic 3D keypoint cleaning** (after triangulation)

   * Detect extreme 3D outliers (per-joint jumps, bone-length violations)
   * Convert 3D outliers → NaN
   * Interpolate short 3D gaps
   * Identify catastrophically bad frames
   * Produce valid-frame and statistics masks

3. **Per-joint data-driven direction statistics**

   * Empirical mean direction (mu_emp)
   * Empirical concentration (kappa_emp)
   * Computed only from original, non-outlier, non-interpolated 3D samples

4. **Construction of per-joint priors**

   * Direction prior: projected-Normal representing vMF-like behavior
   * Concentration prior: Gamma(mode, sd)
   * Delivered as a clean `priors` dictionary consumed by the PyMC model

### In Scope

* 3D cleaning
* Direction statistics
* Prior building
* Integration with `add_directional_hmm_prior` (complete override)
* Updated synthetic demo

### Out of Scope

* PCA (v0.2.7)
* Clustering (v0.2.2)
* Sampler decisions (v0.2.3)
* Real data (v0.2.5)
* Anatomical priors (v0.2.6)

---

## 2. Final Design Decisions

**Cleaning is 3D.** All downstream statistics and priors depend on cleaned 3D.

**Statistics use only original non‑outlier samples.** Interpolated data never contributes.

**Per‑joint mu and kappa.** No pooling.

**No weakening of kappa.** Prior strength equals empirical concentration.

**Priors expressed in actual distribution parameters.**

* Direction: mu (3‑vector), kappa (scalar)
* Concentration: mode, sd (Gamma)

**Model performs Gamma(mode,sd) → (shape,rate).**

**Prior override is complete.** No merging with defaults.

**Directional prior implemented as projected Normal.**

**Minimum samples enforced.** If insufficient samples (<10), use fallback prior.

---

## 3. Module Specifications

```
gimbal/
  triangulation.py
  data_cleaning.py
  direction_statistics.py
  prior_building.py
```

---

# 3.1 triangulation.py

### Purpose

Triangulate multi‑camera 2D keypoints into 3D coordinates.

### Signature

```
def triangulate_multi_view(keypoints_2d, camera_proj, min_cameras=2):
    """Return (T,K,3) triangulated coordinates.
    NaNs in 2D ignored; insufficient views → NaN output.
    """
```

---

# 4. data_cleaning.py

This module handles **both 2D and 3D cleaning**.

## 4.1 CleaningConfig

```
@dataclass
class CleaningConfig:
    jump_z_thresh: float = 3.0
    bone_z_thresh: float = 3.0
    max_gap: int = 5
    max_bad_joint_fraction: float = 0.3
```

The same structure can be used for 2D and 3D; callers may pass different configs if needed.

## 4.2 2D Cleaning

### Signature

```
def clean_keypoints_2d(keypoints_2d, parents, config):
    """
    keypoints_2d: (C,T,K,2)
    parents: (K,)

    Returns:
      keypoints_2d_clean: (C,T,K,2)
      valid_frame_mask_2d: (C,T) boolean (per camera)
      summary_2d: dict with counts (jump_outliers, bone_outliers, interpolated, invalid_frames)
    """
```

### Behavior

* For each camera independently:

  * Detect jump outliers per joint using median/MAD Z-scores.
  * Detect bone-length outliers using 2D distances between parent/child joints.
  * Convert outliers → NaN.
  * Interpolate per joint along time for gaps <= max_gap.
  * Mark invalid frames (per camera) where the fraction of NaN joints exceeds max_bad_joint_fraction.
* No statistics mask is needed at the 2D level; its purpose is to avoid triangulating obvious garbage.

## 4.3 3D Cleaning

### Signature

```
def clean_keypoints_3d(positions_3d, parents, config):
    """
    positions_3d: (T,K,3)
    parents: (K,)

    Returns:
      positions_clean: (T,K,3)
      valid_frame_mask: (T,)
      use_for_stats_mask: (T,K)
      summary: dict with counts (jump_outliers, bone_outliers, interpolated, invalid_frames)
    """
```

### Behavior

1. Detect jump outliers per joint (median/MAD Z-scores).
2. Detect bone-length outliers per bone.
3. Convert outliers → NaN.
4. Interpolate per joint for gaps <= max_gap (3D coordinates). Boundaries remain NaN.
5. Mark invalid frames where > max_bad_joint_fraction of joints are NaN.
6. Build `use_for_stats_mask` that is True only for samples that were original (not NaN, not outlier, not interpolated).

---

# 5. direction_statistics.py.py

### Signature

```
def compute_direction_statistics(positions_3d, parents, use_for_stats_mask, joint_names, min_samples=10):
```

### Outputs

```
{
  joint_name: {
    "mu_emp": (3,),
    "kappa_emp": float,
    "n_samples": int,
    "R_bar": float,
    "is_valid": bool
  }
}
```

### Computation

* Directions: d = x[j] - x[parent(j)]
* Normalize to u[t,j]
* mu_emp = normalized mean of u
* R_bar = |mean(u)|
* kappa_emp via 3‑regime Sra approximation
* is_valid=False if n_samples < min_samples or R_bar < threshold

---

# 6. prior_building.py

### Signature

```
def build_priors_from_statistics(emp_stats, joint_names, kappa_min=0.1, kappa_scale=5.0):
```

### Valid Joints

```
mu_prior = mu_emp
kappa_prior_mu = kappa_scale * kappa_emp
mode = max(kappa_emp, kappa_min)
sd = mode
```

### Invalid Joints

```
mu_prior = [1,0,0]
kappa_prior_mu = kappa_min
mode = kappa_min
sd = kappa_min
```

### Output Dict

```
priors["joint_directions"][joint_name] = {
  "mu": {"mu": mu_prior, "kappa": kappa_prior_mu},
  "kappa": {"mode": mode, "sd": sd},
}
```

---

# 7. Model Integration

### Updated signature

```
def add_directional_hmm_prior(U, log_obs_t, S, *, joint_names, prior_config, ...):
```

### Direction Prior (Projected Normal)

```
mu_raw[s,k] ~ Normal(mu_emp[k], sigma = 1/sqrt(kappa_prior_mu[k]))
mu[s,k] = mu_raw / ||mu_raw||
```

### Concentration Prior

```
ra = (mode + sqrt(mode**2 + 4*sd**2)) / (2*sd**2)
sh = 1 + mode*ra
kappa[s,k] ~ Gamma(shape=sh, rate=ra)
```

---

# 8. Pipeline

1. Clean 2D per camera (`clean_keypoints_2d`).
2. Triangulate cleaned 2D to 3D (`triangulate_multi_view`).
3. Clean 3D (`clean_keypoints_3d`).
4. Compute direction statistics (`compute_direction_statistics`).
5. Build priors (`build_priors_from_statistics`).
6. Build PyMC model and add priors (`add_directional_hmm_prior`).
7. Run sampling or prior predictive.

---

# 9. Tests

### Cleaning

* Jump/bone outliers
* MAD=0 cases
* Interpolation boundaries
* Statistics mask correctness

### Statistics

* Perfect alignment → high kappa
* Uniform → kappa~0
* Low‑sample joints invalidated

### Prior Building

* Gamma(mode,sd) conversion tested
* kappa_min clamp
* Fallback cases

### Integration

* Prior override verified
* Projected Normal stable
* Model builds correctly

---

# 10. Acceptance Criteria

* Cleaning preserves shapes and expected masks
* Statistics use only original data
* Priors follow schema exactly
* Model incorporates priors and converts Gamma correctly
* Synthetic demo updated and stable
* ESS improves relative to unregularized baseline

---

# 11. Review Checklist

* [ ] Triangulation implemented
* [ ] CleaningConfig implemented
* [ ] Statistics mask correct
* [ ] Projected‑Normal prior validated
* [ ] Gamma conversion verified
* [ ] Synthetic demo updated
* [ ] End‑to‑end pipeline passes

---

# End of v0.2.1 Specification
