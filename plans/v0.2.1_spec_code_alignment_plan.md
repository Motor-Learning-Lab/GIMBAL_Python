2. Spec and Code Alignment (v0.2.1) — Action-Oriented Plan

This section defines how Copilot should systematically align the specification documents with the current codebase, and document any intentional divergences. The outcome should be a clear, auditable record of what the code actually does, what the spec says, and which one is treated as authoritative in each case.

All changes to code or specs must be proposed and documented first, not applied silently.

2.1 Objectives of Spec–Code Alignment

By the end of this phase:

All major v0.2.1 specs and plans will be mapped to concrete modules, functions, and tests.

All mismatches between spec and code will be identified, categorized, and documented.

For each mismatch, there will be a recommended resolution:

"Align spec to code" (code is source of truth)

"Align code to spec" (spec is source of truth)

"Defer / needs design decision" (requires human input)

A single alignment report will exist that future versions can consult when modifying the model.

Primary deliverable:

plans/v0.2.1_spec_code_alignment_report.md
2.2 Inputs and Scope

Copilot must work primarily with the following documents and modules (non-exhaustive but mandatory):

Plans / specs (v0.2.1-relevant):

plans/v0.2.1_spec_data_driven_priors.md

plans/v0.2.1_divergence_plan_2.md

plans/v0.2.1_completion_report.md

plans/v0.2.1_debug_model_no_hmm_plan.md

plans/v0.2.1_debug_ground_truth_test_plan.md

plans/v0.2.1_debug_ground_truth_results.md

GIMBAL spec.md (global spec — high-level expectations)

Core code modules:

gimbal/pymc_model.py

gimbal/pymc_utils.py

gimbal/pymc_distributions.py

gimbal/synthetic_data.py

gimbal/prior_building.py

gimbal/skeleton_config.py

gimbal/camera_utils.py

Tests & demos:

tests/integration/test_v0_2_1_data_driven_priors.py

examples/demo_v0_2_1_data_driven_priors.py

notebook/demo_v0_2_1_data_driven_priors.ipynb / .py

Scope: This phase concerns behavior and interfaces, not minor naming or formatting differences.

2.3 Alignment Workflow (What Copilot Must Do)

Copilot must follow this workflow:

Step 1 — Build a Spec–Code Map

For each relevant spec document:

Extract the key promises/requirements, such as:

Model structure (which latent variables exist, shapes, and roles)

Use of data-driven priors for skeleton/joints

Expected behavior of example/demo scripts

Expected test coverage and diagnostics

For each promise, identify the corresponding code locations (modules, functions, tests).

Deliverable: In v0.2.1_spec_code_alignment_report.md, add a section:

## Map: Spec Requirements → Code


| Spec Source | Requirement Summary | Code Location(s) | Notes |

Populate one row per requirement.

Step 2 — Detect and Classify Mismatches

For each requirement–code mapping, Copilot must determine whether:

Aligned: Code and spec say the same thing and behavior matches.

Spec ahead of code: Spec promises behavior that is not implemented or only partially implemented.

Code ahead of spec: Code contains behavior that is not documented in the specs, or specs describe an earlier design.

Conflict: Spec and code describe incompatible behaviors.

For any non-aligned case (2–4), create an entry:

## Mismatch: <Short Name>


- Spec source: <file + section>
- Code location(s): <module: function(s)/class(es)>
- Type: [Spec ahead of code | Code ahead of spec | Conflict]
- Description: <2–4 sentence description>
- Tests affected: <list or "none known">
- Recommendation: <Align spec to code | Align code to spec | Defer>
- Rationale: <short justification>
Step 3 — Apply Resolution Rules (When to Align Spec vs Code)

Copilot must not arbitrarily change behavior. Instead, it should apply the following rules and record them in the report.

Rule A — Favor code when:

The behavior is covered by tests (unit, integration, or diagnostics), and

There is no explicit contradictory text in higher-level specs, and

The behavior appears to be the result of recent debugging or improvements (e.g., divergence fixes).

→ Recommendation: Align spec to code (update spec documents to describe current behavior, marking any design questions for later).

Rule B — Favor spec when:

The spec clearly states a design choice or constraint that is not implemented, and

The missing behavior is important for future extensibility or correctness (e.g., requirement for data-driven priors instead of hard-coded values), and

There is no strong evidence (e.g., completion reports) that the spec was consciously superseded.

→ Recommendation: Align code to spec (create TODOs or issues, or propose concrete code changes, but do not silently change behavior in the plan).

Rule C — Defer when:

Both spec and code are plausible, but imply different future directions, or

Implementing the spec as written would require substantial refactoring, or

You cannot determine intent from available documents.

→ Recommendation: Defer / needs design decision, and explicitly tag the mismatch with NEEDS_DECISION.

Step 4 — Tag Code with Non-Intrusive Markers (Optional but Helpful)

Where mismatches are found, Copilot may propose adding non-intrusive comments such as:

# TODO[v0.2.1-SPEC]: Behavior differs from v0.2.1_spec_data_driven_priors.md, see
# plans/v0.2.1_spec_code_alignment_report.md (Mismatch: <Short Name>)

These comments must be included as proposed edits in the alignment report rather than applied automatically.

2.4 Final Deliverables of Spec–Code Alignment

Copilot must produce or update:

plans/v0.2.1_spec_code_alignment_report.md containing:

Spec→code map table

One subsection per mismatch with classification and recommendation

A short summary listing:

How many mismatches of each type

Which require human decisions

(Optional, proposed only) A list of suggested code comments / TODOs that link to the alignment report.

Only once this report exists and is reasonably complete should we consider spec–code alignment for v0.2.1 done.