# GIMBAL-HMM v0.2.0 — Repository Restructuring & Hygiene Plan

**Purpose:**  
Version 0.2.0 is a **non-algorithmic** phase focused on restructuring, cleanup, and API clarification.  
It prepares the codebase for v0.2.1–0.2.8 (anatomical priors, AIST++, PCA-HMM, etc.) by:

- Making the PyMC HMM pipeline clearly visible and easy to use.
- Isolating legacy Torch code and experimental components.
- Centralizing skeleton definitions and synthetic data utilities.
- Tightening tests and public APIs.
- Reducing cognitive load for future contributors and for AI coding assistants.

v0.2.0 should **not** change the mathematical behavior of the v0.1 pipeline, except where explicitly noted.

---

## 0. Overall Success Criteria for v0.2.0

By the end of v0.2.0:

1. There is a **clearly documented PyMC HMM “world”** (Stage 1–3) with:
   - obvious entry points,
   - minimal duplication,
   - documented APIs.

2. The **Torch-based GIMBAL code** is:
   - still available, *but* explicitly marked as legacy / secondary,
   - clearly separated from the PyMC pipeline.

3. The **v0.1 demo skeleton and synthetic data**:
   - are defined in a **single canonical place**,
   - are imported by notebooks and tests (not redefined ad hoc).

4. The **test suite**:
   - runs cleanly,
   - is organized by stage/module,
   - has at least one smoke test that builds the full v0.1 model.

5. The repo has:
   - a minimal **“hello world” PyMC demo**,
   - clear **README/overview** explaining supported workflows and legacy pieces.

---

## 1. Clarify and Separate Torch vs PyMC “Worlds”

### 1.1. Identify Torch and PyMC components

**Torch-side (legacy) core files:**
- `gimbal/model.py`
- `gimbal/inference.py`
- `gimbal/camera.py`
- `examples/run_gimbal_demo.py`
- Any Torch-focused notebooks in `notebooks/` (e.g., early GIMBAL demos).

**PyMC-side (current v0.1 pipeline):**
- `gimbal/hmm_pytensor.py`  — collapsed HMM engine (Stage 1)
- `gimbal/pymc_model.py`    — camera + kinematics + 2D likelihood (Stage 2)
- `gimbal/hmm_directional.py` — directional HMM prior (Stage 3)
- `gimbal/pymc_utils.py`
- `gimbal/hmm_pymc_utils.py`
- `gimbal/project_points_pytensor.py`
- `gimbal/synthetic_data.py` (if used) and the v0.1 synthetic demo notebook.

### 1.2. Structural changes

**Tasks:**

1. Create a subpackage for Torch code, e.g.: `gimbal/torch_gimbal/`
   - Move:
     - `model.py` → `torch_legacy/model.py`
     - `inference.py` → `torch_legacy/inference.py`
     - `camera.py` → `torch_legacy/camera.py`
   - Update `examples/run_gimbal_demo.py` imports accordingly.

2. In `README.md` (and optionally `gimbal/__init__.py`), add a section:
   - "**PyMC HMM Pipeline (v0.1+)**" — primary focus.
   - "**Torch GIMBAL (legacy)**" — historical / research code.

3. Optionally, add a short `gimbal/torch_legacy/README.md`:
   - explaining that this code is maintained but not the main development path for v0.2+.

**Acceptance criteria:**

- A new contributor can tell immediately:
  - "PyMC HMM pipeline is the main path."
  - "Torch GIMBAL is legacy / secondary."
- No imports are broken by the file moves.

---

## 2. Centralize Skeleton & Synthetic Data for the v0.1 Demo

Right now, the v0.1 synthetic demo skeleton is primarily defined inside notebooks (e.g., `notebooks/demo_v0_1_complete.ipynb` / `.py`), with parent arrays and bone lengths inline.

### 2.1. Create a skeleton config module

**Tasks:**

1. Add a new file, e.g. `gimbal/skeleton_config.py` or `gimbal/skeletons.py`, that defines:

   - A data structure for skeletons, e.g.:

     ```python
     from dataclasses import dataclass
     import numpy as np

     @dataclass
     class SkeletonConfig:
         joint_names: list[str]
         parents: np.ndarray  # shape (K,), -1 for root
         bone_lengths: np.ndarray | None  # optional, shape (K,)
         up_axis: np.ndarray  # e.g. np.array([0, 0, 1])
     ```

   - A function or constant for the **v0.1 demo skeleton**, e.g.:

     ```python
     DEMO_V0_1_SKELETON = SkeletonConfig(
         joint_names=[...],
         parents=np.array([-1, 0, 1, 2, 3, 4]),
         bone_lengths=np.array([...]),
         up_axis=np.array([0, 0, 1]),
     )
     ```

2. Replace hard-coded skeleton definitions in:
   - `notebooks/demo_v0_1_complete.py`
   - `synthetic_data` utilities (if present)
   with imports from `skeleton_config.py`.

### 2.2. Synthetic data utilities

**Tasks:**

1. If not already present, move generic synthetic data generation into `gimbal/synthetic_data.py`:

   - Functions such as:
     - `generate_demo_sequence(skeleton_config, T, noise_config, ...)`
     - `generate_demo_state_sequence(...)`
     - "generate canonical poses" used in Stage 3 demo.

2. The v0.1 demo notebooks should:
   - import `DEMO_V0_1_SKELETON` from `skeleton_config`,
   - import helper functions from `synthetic_data`.

**Acceptance criteria:**

- There is a **single canonical place** where the v0.1 demo skeleton is defined.
- Synthetic generation logic is mostly in `synthetic_data.py` (or similar), not duplicated across notebooks.

---

## 3. Public API for the PyMC HMM Pipeline

We want a small, explicit public API for v0.1/v0.2.

### 3.1. Re-export key functions in `gimbal/__init__.py`

**Tasks:**

1. In `gimbal/__init__.py`, import and re-export:

   ```python
   from .hmm_pytensor import collapsed_hmm_loglik
   from .pymc_model import build_camera_observation_model
   from .hmm_directional import add_directional_hmm_prior
   ```

2. Add short docstrings:

   ```python
   __all__ = [
       "collapsed_hmm_loglik",
       "build_camera_observation_model",
       "add_directional_hmm_prior",
   ]
   ```

   And a module-level docstring describing the three stages and the role of each function.

### 3.2. Internal consistency of names

**Tasks:**

1. Check within `pymc_model.py`, `hmm_directional.py`, `synthetic_data.py`, and notebooks that the following names and shapes are used consistently:

   - `U` shape `(T, K, 3)` — global unit directions
   - `x_all` shape `(T, K, 3)` — joint positions
   - `y_pred` shape `(C, T, K, 2)` — projected 2D points
   - `log_obs_t` shape `(T,)` — per-timestep 2D log-likelihood

2. Replace older aliases (`dirs`, `positions`, etc.) in public-facing code (and at least in the main demo notebook) with the canonical names, or ensure there’s a clear mapping.

**Acceptance criteria:**

- A user can do:

  ```python
  import gimbal

  model, U, x_all, y_pred, log_obs_t = gimbal.build_camera_observation_model(...)
  gimbal.add_directional_hmm_prior(U, log_obs_t, ...)
  ```

  and understand what each of those symbols represents.

---

## 4. Clarify Status of `pymc_distributions.py` and vMF

`gimbal/pymc_distributions.py` defines a `VonMisesFisher` distribution and is used in some earlier tests / notebooks, but the **current Stage 3 directional HMM** in `hmm_directional.py` uses a dot-product energy form instead of full vMF.

### 4.1. Mark vMF as experimental / legacy

**Tasks:**

1. At the top of `pymc_distributions.py`, add a module docstring:

   ```python
   """
   Experimental / legacy PyMC distributions for directional data.

   NOTE: The main GIMBAL-HMM pipeline (Stage 3) currently uses a
   dot-product energy directional prior, not the full VonMisesFisher
   distribution defined here. This module is kept for experiments and
   backwards compatibility.
   """
   ```

2. Check whether any *current* v0.1/v0.2 tests or demos still rely on `VonMisesFisher`:
   - If yes, ensure the tests are clearly marked as experimental.
   - If no, consider moving any vMF-specific tests under a `tests/legacy/` or `tests/experimental/` folder.

**Acceptance criteria:**

- It is clear to a reader that:
  - Stage 3 directional priors use the dot-product approach.
  - vMF is optional / experimental.

---

## 5. Test Suite Organization and Health

We want tests to reflect the Stage 1–3 structure, plus utilities.

### 5.1. Stage-structured tests

**Tasks:**

1. Ensure the tests are logically grouped, for example:

   - `tests/test_hmm_pytensor.py` (or `test_hmm_v0_1_1.py`) — Stage 1
   - `tests/test_pymc_model.py` (or `test_hmm_v0_1_2.py`) — Stage 2
   - `tests/test_hmm_directional.py` (or `test_v0_1_3_directional_hmm.py`) — Stage 3
   - `tests/test_pymc_utils.py` — utilities
   - `tests/test_model_init.py` — initialization behavior etc.

2. If tests still contain v0.1-specific names (`_v0_1_1`, `_v0_1_2`), either:
   - keep them but document that they correspond to Stage 1, 2, 3, or
   - rename them to the more descriptive variants above.

### 5.2. Smoke test for full v0.1 model

**Tasks:**

1. Add a simple smoke test, e.g. `tests/test_demo_v0_1_smoke.py`, that:

   - imports the v0.1 demo as a module (`notebooks/demo_v0_1_complete.py` converted to a script, or a helper function in `synthetic_data.py`),
   - builds the full PyMC model,
   - runs *at most* a tiny number of sampling steps or even only a `pm.sample_prior_predictive()` call.

2. The goal is not to test convergence, but to ensure that:
   - imports work,
   - shapes match,
   - the model graph is buildable.

**Acceptance criteria:**

- `pytest` (or the chosen test runner) runs all tests and passes.
- The full v0.1 model can at least be built in an automated test, catching obvious breakage.

---

## 6. Minimal “Hello World” PyMC Demo

The repo currently has richer demo notebooks; for onboarding and for AI coding tools, it’s helpful to have a minimal script.

### 6.1. Create a simple demo script

**Tasks:**

1. Add something like `examples/demo_pymc_pipeline.py` that:

   - imports `DEMO_V0_1_SKELETON` from `skeleton_config`,
   - uses `synthetic_data.generate_demo_sequence(...)` to create a tiny dataset (e.g. `T=20`),
   - builds a Stage 2 model using `build_camera_observation_model`,
   - adds Stage 3 via `add_directional_hmm_prior`,
   - runs a very short sampling or prior-predictive run,
   - prints a minimal summary (e.g. shape of `U`, `x_all`).

2. The script should be runnable via:

   ```bash
   python -m gimbal.examples.demo_pymc_pipeline
   ```

   (or similar).

**Acceptance criteria:**

- Running the demo gives a quick sanity check that the full pipeline is wired correctly.
- The script is short, heavily commented, and easy to follow.

---

## 7. Configuration & Flags for Future Priors

We know that v0.2.1–0.2.2 will introduce anatomical and EB priors, and later phases will add PCA-informed priors.

### 7.1. Prepare for configuration without fully implementing it

**Tasks:**

1. Update `build_camera_observation_model` and/or `add_directional_hmm_prior` signatures to accept a generic `prior_config` or `prior_hyperparams` dict (if not already present), but:

   - keep default behavior identical to v0.1,
   - do not implement anatomical priors yet.

2. Optionally define an enum-like structure for prior modes:

   ```python
   PRIOR_MODE_NONE = "none"
   PRIOR_MODE_COARSE_ANATOMICAL = "coarse_anatomical"
   PRIOR_MODE_DATA_DRIVEN = "data_driven"
   ```

   without using all of them yet.

**Acceptance criteria:**

- Future phases (0.2.1+) can plug in more sophisticated priors without another round of signature churn.
- v0.2.0 itself does not alter prior behavior.

---

## 8. Documentation & README Updates

We want the repo to explain itself.

### 8.1. Top-level README

**Tasks:**

1. Add or update sections in `README.md`:

   - **"Current pipeline (PyMC HMM, v0.1+)"**
     - Stage 1–3 summary, plus a one-paragraph description.
   - **"Legacy Torch GIMBAL"**
     - short note about historical importance and current status.
   - **"Examples"**
     - point to the minimal PyMC demo script and key notebooks.
   - **"Development roadmap"**
     - brief pointer to `plans/` (where v0.2 roadmap lives).

### 8.2. `plans/` directory

**Tasks:**

1. Place the v0.2.0 plan (this file) under `plans/`, e.g.:

   - `plans/v0_2_0_repo_hygiene.md`

2. Keep the v0.1 overview and v0.2 overviews in the same folder for easy reference.

**Acceptance criteria:**

- A new developer reading `README.md` plus `plans/v0_2_0_repo_hygiene.md` can understand:
  - how the repo is structured,
  - where to start, and
  - what is in scope for v0.2.0 vs later phases.

---

## 9. Branching / Versioning Practices

v0.2.0 is a good time to clarify branching.

### 9.1. Git tags and branches

**Tasks:**

1. Tag the stable v0.1 state (if not already done), e.g.:

   ```bash
   git tag v0.1.0
   git push origin v0.1.0
   ```

2. Ensure that v0.2.0 work is done on:
   - `main` (if that is your standard), or
   - a dedicated branch like `v0.2-dev`, with PRs into `main`.

3. Optionally, add a short `CONTRIBUTING.md` or section in `README.md` describing:
   - expected test running (`pytest`),
   - code style preferences,
   - branching/PR expectations.

**Acceptance criteria:**

- It is possible to check out v0.1.0 easily.
- v0.2.0 changes are grouped in a way that is reviewable and revertible.

---

## 10. Non-Goals for v0.2.0

To keep this phase focused, v0.2.0 explicitly **does not**:

- Change the mathematical structure of Stage 1–3.
- Introduce anatomical priors or EB priors (that begins in v0.2.1).
- Add AIST++ loaders or real-data pipelines (v0.2.5+).
- Implement PCA-based priors or state-number selection (v0.2.7–0.2.8).

It is purely about **structure, clarity, and future-proofing**.

---

## Summary

v0.2.0 cleans the house so that:

- v0.2.1 (anatomical priors & cleaning),
- v0.2.2 (k-means EB priors),
- v0.2.5 (AIST++ loader),
- and onward

can be implemented on a clean, understandable, and stable foundation.

This plan should be reviewed and refined collaboratively (e.g., with Copilot / Sonnet) before implementation, but the goal is to **avoid surprises later** by making the structural intentions explicit now.
