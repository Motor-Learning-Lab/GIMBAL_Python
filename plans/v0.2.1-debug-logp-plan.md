# Model Log Probability Debugging - Implementation Plan

**Script**: `tests/diagnostics/v0_2_1_divergence/debug_model_logp.py`  
**Date**: 2025-12-10

---

## Purpose

Systematically debug which parameter(s) cause the -inf log probability in GIMBAL v0.2.1 by examining each parameter's contribution individually.

---

## What the Script Does

### Three-Step Debugging Process

#### STEP 1: Per-Parameter Log Probability Analysis
**Function**: `debug_model_logp_by_parameter()`

For each of the 42 model parameters, checks:
- **Value at test point**: min, max, mean
- **Value validity**: Contains NaN? Contains inf?
- **Log probability contribution**: Computed individually
- **Finiteness**: Is the logp finite or -inf?

**Output**: 
- CSV file with all parameter statistics
- Console output showing each parameter's status

#### STEP 2: PyMC's Built-in Debug
**Function**: `debug_with_model_debug_method()`

Uses PyMC's `model.debug(point, fn='logp', verbose=True)` which:
- Evaluates the log probability function for each variable
- Prints detailed PyTensor graph when evaluation fails
- Shows exactly where computation produces non-finite values
- Provides stack traces for errors

**Based on**: [PyMC debugging documentation](https://www.pymc.io/projects/docs/en/v5.4.1/api/generated/classmethods/pymc.Model.debug.html)

#### STEP 3: Prior Specification Review
**Function**: `check_prior_specifications()`

Lists all parameters with their:
- Distribution type
- Transformation (log, logit, etc.)
- Shape/dimensionality

Helps identify priors that might allow invalid values.

---

## Key Features

### Diagnostic Capabilities

1. **Isolates the culprit**: Tests each parameter independently
2. **Detects boundary issues**: Identifies inf/NaN values
3. **Verbose mode**: Can show detailed PyTensor computation graphs
4. **Comprehensive report**: Generates markdown summary

### Safety Features

- Uses known good data (ground truth synthetic)
- Only analyzes, doesn't modify the model
- Captures all output for review
- Generates structured reports

---

## Expected Output

### Files Generated

1. **`parameter_logp_results.csv`**
   - One row per parameter
   - Columns: parameter name, shape, value range, logp, is_finite, notes

2. **`debug_logp_report.md`**
   - Formatted markdown report
   - Lists all parameters with infinite logp
   - Recommendations for each problematic parameter

### Console Output Structure

```
STEP 1: Analyzing per-parameter log probabilities
==================================================

[1/42] eta2_root
------------------------------------------------------------
  Value shape: scalar
  Value range: [60.0000, 60.0000]
  Value mean:  60.0000
  Log probability: -2.3456
  [OK] Log probability is FINITE

[2/42] inlier_prob
------------------------------------------------------------
  Value shape: scalar
  Value range: [0.9500, 0.9500]
  Value mean:  0.9500
  Log probability: -inf
  [FAIL] Log probability is INFINITE

...

SUMMARY
==================================================
Total log probability: -inf

[FAIL] Found 1 parameters with infinite log probability:
  - inlier_prob
```

---

## How It Works

### Per-Parameter Testing

The key insight is testing each parameter's log probability **independently**:

```python
# Instead of checking all parameters together:
total_logp = model.compile_logp()(test_point)  # Returns -inf

# Check each parameter separately:
for rv in model.free_RVs:
    logp_fn = model.compile_logp(vars=[rv], sum=True)
    logp_val = logp_fn(test_point)  # Which one is -inf?
```

This isolates which parameter(s) cause the problem.

### PyMC Debug Method

PyMC's `model.debug()` goes deeper by:
1. Building the computation graph for log probability
2. Evaluating each node in the graph
3. Stopping when it hits an error or non-finite value
4. Printing the graph structure and intermediate values

From the [PyMC docs](https://www.pymc.io/projects/docs/en/v5.4.1/api/generated/classmethods/pymc.Model.debug.html):
> "When an evaluation fails or produces a non-finite value we print:
> 1. The graph of the parameters
> 2. The value of the parameters (if those can be evaluated)
> 3. The output of fn (if it can be evaluated)"

---

## Usage

### To Run

```bash
# Run the complete debug workflow
pixi run python tests/diagnostics/v0_2_1_divergence/debug_model_logp.py
```

### To Use Functions Separately

```python
from tests.diagnostics.v0_2_1_divergence.debug_model_logp import (
    debug_model_logp_by_parameter,
    debug_with_model_debug_method,
    check_prior_specifications
)

# After building your model:
results_df, total_logp = debug_model_logp_by_parameter(model)
debug_with_model_debug_method(model)
check_prior_specifications(model)
```

### In a Notebook

The script can also be imported and used interactively in a Jupyter notebook for step-by-step exploration.

---

## What to Look For

### Red Flags in Results

1. **Parameter with inf value**
   - Indicates transformation or initialization issue
   - Check: Is it a log/logit transformed parameter?
   - Check: Is the constrained value hitting a boundary (0, 1)?

2. **Parameter with finite value but -inf logp**
   - Indicates prior specification issue
   - Check: Does the prior have support at this value?
   - Check: Is the prior too narrow/strict?

3. **All parameters finite, but total -inf**
   - Indicates interaction issue or likelihood problem
   - Check: Observed data compatibility
   - Check: Shape mismatches between parameters and data

### Common Culprits

Based on previous tests showing `inlier_prob_logodds__: inf`:

1. **`inlier_prob`** - Beta or Uniform prior allowing boundary values?
2. **`obs_sigma`** - HalfNormal prior allowing zero?
3. **HMM kappa** - Concentration parameters going negative?
4. **Bone lengths** - Negative or zero lengths?

---

## Next Steps After Running

### If Script Identifies Problem Parameters

1. **Check prior specification** in `gimbal/pymc_model.py` or `gimbal/pymc_utils.py`
2. **Check transformation** - Is log/logit applied correctly?
3. **Check initialization** - Are default values valid?
4. **Add constraints** - Use `pm.Bound` or restrict prior support

### If No Single Parameter is Culprit

1. **Check parameter interactions** - Are combinations invalid?
2. **Check likelihood specification** - Is observed data compatible?
3. **Check shapes** - Broadcasting issues can cause mysterious -inf
4. **Add intermediate Print statements** - Use `pytensor.printing.Print`

---

## Technical Notes

### Why This Approach Works

- **Decomposition**: Breaking total logp into components
- **Isolation**: Testing one variable at a time
- **Automation**: Systematic rather than manual inspection
- **Reporting**: Structured output for later analysis

### Limitations

- May not catch issues that only appear when parameters interact
- Requires model to at least build successfully
- Cannot fix the issue, only diagnose it

### Performance

- Takes ~1-2 minutes for 42 parameters
- Verbose mode adds significant time
- CSV output enables further analysis

---

## Reference

**PyMC Documentation**:
- [model.debug() API](https://www.pymc.io/projects/docs/en/v5.4.1/api/generated/classmethods/pymc.Model.debug.html)
- [Debugging howto](https://www.pymc.io/projects/examples/en/latest/howto/howto_debugging.html)

**Related Files**:
- `tests/diagnostics/v0_2_1_divergence/test_ground_truth_init.py` - Shows problem exists
- `plans/v0.2.1-ground-truth-init-summary.md` - Context and background
- `gimbal/pymc_model.py` - Model specification to fix
