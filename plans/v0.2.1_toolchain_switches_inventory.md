# v0.2.1 Step 4: API Inventory & Toolchain Switches

**Created:** December 19, 2025  
**Purpose:** Document all gimbal functions, their switches/options, and usage in fitting pipeline Stages A-J

This inventory satisfies Step 4.0 Phase 4.3.1 requirement before adding new switches.

---

## Stage A: Load & Validation

**No gimbal functions** - direct dataset loading

Options:
- Dataset path (input)
- Validation thresholds (NaN tolerance, bounds checking)

---

## Stage B: 2D Cleaning

### `gimbal.data_cleaning.clean_keypoints_2d()`

**Location:** `gimbal/data_cleaning.py`

**Function Signature:**
```python
def clean_keypoints_2d(
    keypoints_2d: np.ndarray,
    config: CleaningConfig
) -> np.ndarray
```

**Options (via CleaningConfig):**
| Option | Type | Default | Meaning | Used in Stage |
|--------|------|---------|---------|---------------|
| `outlier_method` | str | "mad" | Outlier detection method (mad/zscore) | B |
| `outlier_threshold` | float | 3.0 | MAD multiplier or z-score threshold | B |
| `temporal_window` | int | 5 | Window size for temporal smoothing | B |
| `min_valid_frames` | int | 3 | Min frames required in window | B |
| `interpolate_gaps` | bool | True | Whether to fill gaps via interpolation | B |

---

## Stage C: Triangulation

### `gimbal.triangulation.triangulate_multi_view()`

**Location:** `gimbal/triangulation.py`

**Function Signature:**
```python
def triangulate_multi_view(
    keypoints_2d: np.ndarray,
    camera_matrices: np.ndarray,
    method: str = "dlt",
    min_cameras: int = 2
) -> np.ndarray
```

**Options:**
| Option | Type | Default | Meaning | Used in Stage |
|--------|------|---------|---------|---------------|
| `method` | str | "dlt" | Triangulation algorithm (dlt/optimal) | C |
| `min_cameras` | int | 2 | Minimum cameras required for valid 3D point | C |

**Returns:** 3D points (T, K, 3) with NaN for under-determined points

---

## Stage D: 3D Cleaning

### `gimbal.data_cleaning.clean_keypoints_3d()`

**Location:** `gimbal/data_cleaning.py`

**Function Signature:**
```python
def clean_keypoints_3d(
    keypoints_3d: np.ndarray,
    skeleton: SkeletonConfig,
    config: CleaningConfig
) -> np.ndarray
```

**Options (via CleaningConfig):**
| Option | Type | Default | Meaning | Used in Stage |
|--------|------|---------|---------|---------------|
| `bone_length_tolerance` | float | 0.2 | Max deviation from expected length (fraction) | D |
| `temporal_window` | int | 5 | Smoothing window size | D |
| `smooth_method` | str | "savgol" | Smoothing method (savgol/median) | D |

---

## Stage E: Direction Statistics

### `gimbal.direction_statistics.compute_direction_statistics()`

**Location:** `gimbal/direction_statistics.py`

**Function Signature:**
```python
def compute_direction_statistics(
    u_3d: np.ndarray,
    joint_names: Optional[list[str]] = None
) -> Dict[str, Any]
```

**Options:**
| Option | Type | Default | Meaning | Used in Stage |
|--------|------|---------|---------|---------------|
| `joint_names` | list[str] | None | Optional joint names for labeling | E |

**Returns:** Dict with:
- `mean_directions`: (K, 3) mean direction per joint
- `kappa_estimates`: (K,) concentration estimates
- `counts`: (K,) valid frame counts

---

## Stage F: Prior Building

### `gimbal.prior_building.build_priors_from_statistics()`

**Location:** `gimbal/prior_building.py`

**Function Signature:**
```python
def build_priors_from_statistics(
    direction_stats: Dict[str, Any],
    kappa_scale: float = 1.0
) -> Dict[str, Any]
```

**Options:**
| Option | Type | Default | Meaning | Used in Stage |
|--------|------|---------|---------|---------------|
| `kappa_scale` | float | 1.0 | Multiplier for concentration parameters | F |

**Returns:** Dict with PyMC-compatible prior specifications

---

## Stage G: Model Building

### `gimbal.pymc_model._build_camera_observation_model_full()`

**Location:** `gimbal/pymc_model.py`  
**Public alias:** `gimbal.build_camera_observation_model`

**Function Signature:**
```python
def _build_camera_observation_model_full(
    y_observed: np.ndarray,
    camera_proj: np.ndarray,
    parents: np.ndarray,
    init_result: InitializationResult,
    use_mixture: bool = True,
    image_size: tuple[int, int] = (640, 480),
    prior_hyperparams: Optional[dict] = None,  # DEPRECATED
    validate_init_points: bool = False,
    use_directional_hmm: bool = False,
    hmm_num_states: Optional[int] = None,
    hmm_kwargs: Optional[dict] = None,
    **kwargs
) -> pm.Model
```

**Options:**
| Option | Type | Default | Meaning | Used in Stage |
|--------|------|---------|---------|---------------|
| `use_mixture` | bool | True | Use mixture likelihood (inlier/outlier) vs simple Gaussian | G |
| `image_size` | tuple | (640,480) | Image dimensions for outlier uniform distribution | G |
| `validate_init_points` | bool | False | Validate initialization shapes/values | G |
| `use_directional_hmm` | bool | False | Add Stage 3 directional HMM prior | G |
| `hmm_num_states` | int | None | Number of HMM states (required if use_directional_hmm=True) | G |
| `hmm_kwargs` | dict | None | Additional HMM options (see below) | G |
| `sigma_dir` | float | 1.0 | Std dev for raw directional vectors (via kwargs) | G |

**HMM kwargs (when use_directional_hmm=True):**
| Option | Type | Default | Meaning | Used in Stage |
|--------|------|---------|---------|---------------|
| `name_prefix` | str | "dir_hmm" | Prefix for HMM variable names | G |
| `share_kappa_across_joints` | bool | False | Share concentration across joints | G |
| `share_kappa_across_states` | bool | False | Share concentration across states | G |
| `kappa_scale` | float | 5.0 | Scale for kappa prior | G |

**Current Limitations (for Step 4):**
- ❌ **No option to fix cameras** - cameras are always estimated
- ❌ **No option to fix bone lengths** - lengths are always estimated
- ✅ HMM can be disabled via `use_directional_hmm=False`
- ✅ Number of states configurable via `hmm_num_states`

**Required additions for Step 4:**
Need to add parameters to disable estimation:
- `estimate_cameras: bool = True` - if False, treat camera_proj as fixed
- `estimate_bone_lengths: bool = True` - if False, treat bone lengths as fixed

---

## Stage G (continued): Directional HMM Prior

### `gimbal.hmm_directional.add_directional_hmm_prior()`

**Location:** `gimbal/hmm_directional.py`

**Function Signature:**
```python
def add_directional_hmm_prior(
    U: pt.TensorVariable,
    log_obs_t: pt.TensorVariable,
    S: int,
    name_prefix: str = "dir_hmm",
    share_kappa_across_joints: bool = False,
    share_kappa_across_states: bool = False,
    share_kappa: bool = False,
    kappa_scale: float = 5.0
) -> None
```

**Options:**
| Option | Type | Default | Meaning | Used in Stage |
|--------|------|---------|---------|---------------|
| `S` | int | (required) | Number of HMM states | G |
| `name_prefix` | str | "dir_hmm" | Prefix for variable names | G |
| `share_kappa_across_joints` | bool | False | Share κ across all joints | G |
| `share_kappa_across_states` | bool | False | Share κ across all states | G |
| `share_kappa` | bool | False | Share κ globally (overrides above) | G |
| `kappa_scale` | float | 5.0 | Prior scale for concentration | G |

**Note:** For K=1 (single state), transition matrix is [[1.0]] (deterministic self-loop)

---

## Stage H: Fitting/Sampling

### `gimbal.fit_params.initialize_from_observations()`

**Location:** `gimbal/fit_params.py`

**Function Signature:**
```python
def initialize_from_observations(
    y_observed: np.ndarray,
    camera_proj: np.ndarray,
    parents: np.ndarray,
    bone_lengths: np.ndarray,
    method: str = "dlt"
) -> InitializationResult
```

**Options:**
| Option | Type | Default | Meaning | Used in Stage |
|--------|------|---------|---------|---------------|
| `method` | str | "dlt" | Initialization method (dlt/anipose) | H |

**Returns:** InitializationResult with x_init, eta2, rho, sigma2, u_init, obs_sigma, inlier_prob

### PyMC Sampling Options

**Location:** `pymc.sample()` standard API

**Options:**
| Option | Type | Default | Meaning | Used in Stage |
|--------|------|---------|---------|---------------|
| `draws` | int | 1000 | Number of posterior samples per chain | H |
| `tune` | int | 1000 | Number of tuning samples | H |
| `chains` | int | 4 | Number of MCMC chains | H |
| `cores` | int | 1 | CPU cores for parallel chains | H |
| `target_accept` | float | 0.8 | Target acceptance rate for NUTS | H |
| `return_inferencedata` | bool | True | Return ArviZ InferenceData object | H |

**Step 4 short run:** `draws=200, chains=2`

---

## Stage I: Posterior Diagnostics

**Functions:**
- `pm.sample_posterior_predictive()` - Generate predictions from posterior
- Custom reprojection error calculation

**Options:**
| Option | Type | Default | Meaning | Used in Stage |
|--------|------|---------|---------|---------------|
| `samples` | int | None | Number of posterior samples to use (None = all) | I |

---

## Stage J: Ground Truth Comparison

### Custom metrics (to be implemented)

**Functions to create:**
- `compute_3d_rmse(x_pred, x_true)` → per-joint RMSE
- `compute_angular_error(u_pred, u_true)` → per-joint angular deviation (degrees)
- `compute_state_accuracy(z_pred, z_true)` → fraction correct (trivial for K=1)

**No existing gimbal functions** - these are new diagnostic utilities

---

## Summary: Required API Changes for Step 4

### Immediate Need (Phase 4.0.B)

**Add to `_build_camera_observation_model_full()`:**
```python
def _build_camera_observation_model_full(
    ...,
    estimate_cameras: bool = True,      # NEW: if False, fix camera parameters
    estimate_bone_lengths: bool = True, # NEW: if False, fix bone lengths
    ...
)
```

**Implementation approach:**
- When `estimate_cameras=False`: Don't sample camera parameters, use camera_proj as-is
- When `estimate_bone_lengths=False`: Don't sample rho/sigma2, use init_result.rho as fixed values

### Future Enhancements (Post-Step 4)

- Richer prior specifications (data-driven priors from Stage F)
- Camera intrinsic/extrinsic separation for partial estimation
- Bone length group constraints (e.g., symmetric limbs)

---

## Document Status

- [x] Inventory created
- [x] Current options documented
- [x] Required additions identified
- [ ] API modifications implemented (next step)
